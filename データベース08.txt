Chapter08 複数テーブルの操作

8-1 複数テーブルを結合する

・リレーショナルデータベースの本領は、
       ↓                      複数のテーブルを組み合わせて操作することにある。
  テーブル同士を結び付ける
                   ↑
  「同じ値のある列」をもとに結び付ける場合もあれば、
  「同じ値のない列」どうしを結び付ける場合もある。

A テーブルの管理方法）テーブル作成後の修正の手間を軽減できるように考慮する！
 [例] 売上テーブル [図8-2]

      ｜日付｜取引先｜売上｜住所｜電話番号｜
      
                          ｜←----------→｜
         ※異なる日付で同じ取引先があるたびに、
           同じ情報を記述することは使い勝手が悪い！
                                   ↓
       『正規化』：取り扱う情報ごとに分けてテーブルを作成する作業
           ↓                      ↓
       売上テーブル           住所テーブル
       
       ｜日付｜取引先｜売上｜   ｜住所｜電話番号｜
       
    ※リレーショナルデータベースでは、利用する際に必要なテーブルを連携させた
                 ↑                   テーブルを作成委、そのテーブルから必要な
      テーブルを分けて管理し、        データを操作する。
      組み合わせて活用する！

    ※正規化して分けたテーブルの作成のポイント）
    ★各テーブルのレコードに固有の番号（レコードが一意に決まる番号）を割り当てる。
    [利点] その番号で他のテーブルを管理することで、万が一内容に変更が発生した場合、
           修正箇所を最小限に抑えることができる[図8-3]。

    ※正規化は設計の段階で寝る作業であり、その成果物の1つとしてER図がある。
      正規化をどこまでの段階まで進めるか（どこまで分けるか）は、想定する利用
      状況に依る[p.194 コラム]

B テーブルの結合方法）互いのテーブルのカラムどうしをもとに結合する。
【結合の種類】△①和集合（UNION結合）
              〇②内部結合←外部結合とともによく使われる。
              〇③外部結合←内部結合とともによく使われる。
              ×④交差結合←ほぼ使われないが、現象は知っておくとよい。

△① 和集合（UNION結合）
     →複数のテーブルのカラム情報が同じである場合、そのまま結合できる。
                                    →カラムの数とデータ型が同じ！

 [カラムが保管される結合]
〇② 内部結合
     →複数のテーブルの『共通』レコードのみ取り出す結合
       ※レコード数は減る可能性がある！
〇③ 外部結合
     →主たるテーブルを基準に、副たるテーブルのカラム情報が追加される結合
            ↑
            
       ※レコード数は、主たるテーブと同じ！
         カラムのデータは、副たるテーブルに情報がない場合、『NULL』になる！

×④ 交差結合（総当たりの結合）
     →カラム数は、あるテーブルAと別テーブルBの和（+）になる。
                  [例] テーブルA：3カラム、テーブルB：2カラム
                       →結合したテーブル：3+2カラム
     →レコード数は、あるテーブルAと別テーブルBの積（*）になる。
                  [例] テーブルA:4レコード、テーブルB：4レコード
                       →結合したテーブル：4*4レコード


8-2 和集合

 [構文] SELECT カラム名リスト FROM テーブル名1
        UNION [ALL]
        SELECT カラム名リスト FROM テーブル名2;

 ※ オプション）何も指定しない、あるいは DISTINCT →重複レコードを除去
                ALL                               →重複レコードを含む

【確認】SELECT idju, company, state< address FROM jusho
        UNION ALL
        SELECT idur, company, state,area FROM uriage;

  ※上記の例では、重複レコードがないため、ALLオプションの有無に関係なく、
    同じレコード数になる！

 [メモ] DISTINCTオプションは、phpMyAdminでは働かない！？
        →実行時エラーなく動作するが、最初のSELECT文のみ実行される
          一方、コマンド操作では問題なく実行される。

8-3 内部結合

互いのテーブルに共通するレコードの数を増やす結合ではなく、
                        カラムの数を増やす結合になる。

 [構文①] FROM句のテーブル情報を拡張する形式
  SELECT カラム名リスト FROM テーブル１
                        INNNER JOIN テーブル2
                        ON テーブル1.カラム名1=テーブル2.カラム名2;

【確認】
 [リスト8-4] SELECT * FROM uriage
                      INNER JOIN jusho
                      ON uriage.company=jusho.company;

 [構文②] FROM句にテーブルを列挙し、WHERE句に結合条件を記述する形式
  SELECT カラム名リスト FROM テーブル1,テーブル2
                        WHERE テーブル1.カラム名１=テーブル2.カラム名2;

【確認】
 [リスト8-6] SELECT * FROM uriage,jusho
             WHERE uriage.company=jusho.company;
           ※上記コードで、WHERE句を記述し忘れた場合、
             自動的に交差結合となるので要注意！
             このような事故にもつながるため、
             基本的にはINNER JOINで記述しよう。

8-4 外部結合

互いのテーブルの一方を基準に他のレコードのカラムの情報を追加する結合になる。

 [構文] FROM句のテーブル情報を拡張する形式
  SELECT カラム名リスト FROM テーブル1 LEFT/RIGHT [OUTER] JOIN テーブル2
                                左                               右
                        ON テーブル1.カラム名1=テーブル2.カラム名2;

  ※JOINキーワードに対して、
   『左』側、上記の例ではテーブル1、を基準に
                         テーブル2の情報を追加する結合を『左』外部結合とよぶ。
   『右』側、上記の例ではテーブル2、を基準に
                         テーブル1の情報を追加する結合を『右』外部結合とよぶ。
【確認】
 [左外部結合]
  SELECT *FROM uriage LEFT OUTER JOIN jusho
          ON uriage.company = jusho.company;

 [右外部結合] 通常は使用しない！→実行結果の2ページ目で確認してみよう。id等がnullに、、、
  SELECT * FROM uriage RIGHT OUTER JOIN jusho
           ON uriage.company = jusho.company;

 [メモ] 主たるテーブルのカラムに該当する値が副になるテーブルにない場合、
        NULLが格納される。
        通常、重要度・必要度の高いカラムから左に配置されるため、左側のカラムに
        NULLが格納される右外部結合はあまり使われない。


8-5 サブクエリ

リテラル値の代わりに別のSQL文の結果を利用して、SQL文を実行することができる。
                        ↑                       ↑
                    副問い合わせ              主問い合わせ
                    サブクエリ                親問い合わせ

利用箇所）・SELECT、UPDATE、DELETE文のWHERE句
          ・UPDAT、INSERT文のカラムの値

 [構文] SELECT カラム名リスト FROM テーブル       ←親問い合わせ
        WHERE テーブル1.カラム名1 演算子(SELECT文);
                                          ↑
                                        サブクエリ

【確認】
 [リスト8-11] SELECT * FROM uriage
              WHERE charge > (SELECT AVG(charge) FROM uriage);

 通常は、①SELECT AVG(charge) FROM uriage; を実行して、
                                             平均売上金額を求める。
                                                  ↓
 その後、②SELECT * FROM uriage WHERE charge > 平均売上金額;を実行する。
 この場合、SQL文を2回実行することになる。

 サブクエリを利用すると1回の実行結果で目的の情報を得ることができ、効率がよい


【種類】4種類あるが、実質は2種類で、残り2種類は特殊。
  ① スカラクリエ（戻り値：1つ）
     →サブクエリのSELECT句には集約関数などが指定される。
     →親問い合わせの絞り込み条件で使用する演算子は、大小比較の演算子を使用する

  ② カラムクエリ（戻り値：複数）
     →サブクエリのSELECT句には1つのカラム名が指定される。
     →親問い合わせの絞り込み条件で使用する演算子は、IN演算子などを使用する。

  ③ 行クエリ
     →サブクエリの結果は、複数のカラムと1レコードの情報をもつ。

  ④ テーブルクエリ
     →サブクエリの結果は、複数のカラムおよびレコードの情報をもつ。


【EXISTS演算子の利用】
  →条件を満たすレコードの存在を確認する演算子
    ※レコード数を確認する演算子ではない！
                          →COUNT関数を利用

    [例] SELECT EXISTS(SELECT * FROM uriage WHERE salesdate >= '2017-09-01'
                                              AND salesdate <= '2017-09-30');

     ※該当するレコードがあれば、
              1レコードでも複数レコードでも同じ結果、すなわちTRUE（1）を返す。

【確認】
 [図8-26]     SELECT * FROM jusho
 [リスト8-12] WHERE EXISTS(SELECT * FROM uriage
                           WHERE jusho.company=uriage.company
                           AND salesdate >= '2017-09-01'
                           AND salesdate <= '2017-09-30');

EXISTS句]
  ①売上テーブルに
  ②9月の売り上げデータのある、住所テーブルにある会社のレコードがあるか否か

  親問い合わせ）
  該当するレコードがあれば、親問い合わせのSQL文を実行する。
                  なければ、                     実行しない。

【比較：IN演算子】
  SELECT * FROM jusho
  WHERE company IN(SELECT company FROM uriage WHERE salesdate >= '2017-09-01'
                                                AND salesdate <= '2017-09-30')

IN句]
  ①売上テーブルに
  ②9月の売り上げデータのある会社を調べる。

  親問い合わせ）
  該当する会社のレコードを調べて、親問い合わせのSQL文を実行する。


※つまり、EXISTS句は、テーブル全体を参照して、レコードの有無を確認していて、
  IN演算子は、レコード１つ１つを参照して売り上げデータがあるか調べる。
  なので、処理速度がEXISTS句のほうが早い。場合によって使い分けよう。
10-1 インデックス
       ↑
特定のkラムのレコードを検索するための仕組み
イメージ）本の索引
          キーワードを1ページから順番に探さなくても索引で紐づけられている
          ページをもとに検索すれば、効率よくキーワードを見つけることができる。

インデックスを作成
  ↓  検索対象のカラムとレコードを順番に紐づけて管理
  ↓  【メリット】  本の索引を利用して目的のキーワードを含むページを検索できる
  ↓                ように、効率よくキーワードを含むレコードを検索できる。
  ↓  【デメリット】①本の索引にページ数を割くように、インデックスに容量を割く
  ↓                  必要がある。
  ↓                ②対象のカラムが更新されると当然インデックスも更新する必要
  ↓                  があるため、更新処理に時間を要する。
  ↓
検索アルゴリズムの活用：Bツリーなど
  ↓  検索対象のキーワードをインデックスから効率よく検索するためのアルゴリズム
  ↓  (例] ほんの索引のように、キーワードをアルファベット順に整理する、など）
  ↓
テーブルから目的のキーワードを含むレコードを検索

【インデックスの種類】
  ①PRIMARY：主キーの設定に採用
             一意でなければならない。1つのテーブに1つだけ設定可能。
  ②UNIQUE ：ユニークキーの設定に採用
             複数レコードを持つことはできない。
             ユニークキーは複数のカラムで設定できるので、必ずしもインデックス
             内のカラムがユニークであることを意味するのではなく、これらの
             カラム間のデータの組み合わせがユニークであることを意味する。
  ③INDEX  ：通常のカラムの設定に使用
             主キーやユニークキーではない場合、テーブルに挿入されたデータを
             制約することはできないが、より効率的にデータを検索することが
             できる。
  ④FULLTEXT：全文検索を可能にする、より専門的なインデックスの形式。
              基本的には、指定されたカラム（テキスト型）の各単語に対して、
              インデックスを作成する。

【インデックスの確認】
  ※ MySQLでは、主キーや外部キーを設定したカラムにはインデックスが設定される。

 [基本構文]SHOW INDEX FROM テーブル名;
【確認】   SHOW INDEX FROM jusho;

 [phpMyAdmin] [P.246]
  →テーブルを選択＞[構造]タブ＞下部の「インデックス」メニューを展開

【インデックスの作成】
 [基本構文] ALTER TABLE テーブル名 ADD INDEX (カラム名リスト);
              ↑                                    ↑
            作成済みの項目に対して               単一カラムだけでなく、
            変更を加えるときに使用する命令       複数カラムにも設置可能

【確認】
 [SQL] ALTER TABLE jushoADD INDEX(company);

 [phpMyAdmin]
    ①テーブルを選択＞[構造]タブ＞下部の「インデックス」メニューを展開
                                ＞実行
    ②表示されるインデックスの設定画面から下記の項目を指定＞実行
      ・Index choice：インデックスの種類（今回は、INDEXを選択）
      ・カラム      ：設定するカラム    （今回は、stateを選択）
    ③インデックスの表示領域（手順①）に作成したインデックスが追加される。

【インデックスの使用状況の確認】
  実行するSQL文の前に「EXPLAIN」キーワードを記述して、実行すると実行計画が
  表示される。

 [基本構文]EXPLAIN SQL文;

※ 実行計画で着目すべき項目]type、Extraの2項目
★ type ：「ALL」、「index」が表示されていないか？
         ALL ：インデックスを使用せず、テーブルのフルスキャン（完全走査）が
               実行されることを意味する。←とても遅い処理
         index:ALLと違い、インデックスは使われる。
               しかし、インデックスをフルスキャンする必要のある遅い処理である
               ※ただし、ORDER BYとLIMITを組み合わせた場合のように、先頭の
                 数レコードだけを読み込めばよい場合は大きな問題にはならない。

★ Extra：「Using filesort」、「Using temporary」が表示されていないか？
          並べ替えは対象レコード数が少なければ問題にならないが、レコード数が
          多い場合は処理速度に影響を与える。
          ※ Using filesort、Using temporaryの組み合わせは、
           「対象が多すぎるので、一時的なテーブルを作成して並べ替えを行う」
             ことを意味している。その場合、インデックスを検討するとよい。


【インデックスの削除】
 [基本構文] ALTER TABLE テーブル名 DOROP INDEX インデックス名※;
 
【確認】SHOW INDEX FROM jusho; ←インデックス名を調べる（今回：compony）
        ALTER TABLE jusho DROP INDEX company;

 [phpMyAdmin] [p.252]
     ①テーブルを選択＞[構造]タブ＞下部の「インデックス」メニューを展開
     ②削除したいインデックスのレコードに対して「削除」メニューをクリック
       今回の削除対象のインデックスは「state」とする。


10-2 ビュー

・SELECT文による結果をもとに作成される「仮想的」なテーブル

  →通常は、「結合」した互いのテーブルから必要なカラムを抽出したテーブル

・ビューは、あらかじめ仕込まれたSELECT文の実行結果をみる機能であり、
           （→言い換えれば、SQL文に名前を付けて保存する機能ともいえる）
  実行結果であるビューは参照するたびに新しく作成される。

※通常のテーブルとの違い
・通常のテーブルの情報は作成した時点での情報であり、
  作成元のテーブルが更新されたら、それに合わせて更新する必要がある。
  →自動的に更新されない！
・ビューにインデックスは作成できない。
  ビューに対してWHERE句で条件を付けたり、       ←[リスト10-14]
  ビューを他のテーブルや他のビューと結合したり、←[リスト10-15]
  すると、処理速度が低下する場合がある。

【ビューの作成】
 [基本構文] CREATE VIEW ビュー名 AS SQL文;
 [使用例]
 [リスト10-9] CREATE VIEW uriagedenwa AS
 [リスト10-10]SELECT idur,uriage.company,charge,salesdate,tel
                          [p.256]コラム
              FROM uriage INNER JOIN jusho ON uriage.company=jushso.company;

  ※ビューの作成は一回のみ！

【ビューの使用】
 [リスト10-10] SELECT * FROM uriagedenwa;
  ※通常のテーブルと同じように参照すればよい。
    →使用するたびに、互いのテーブル同士を結合するSQL文を実行する必要はない！

 [リスト10-14] SELECT * FROM uriagedenwa WHERE charge>=200000
               ORDER BY salesdate;

 [リスト10-15] SELECT * FROM uriagedenwa LEFT OUTER JOIN jusho
                                         ON urigedenwa.company=jusho.company;

【ビューの更新】
  〇参照する（SELECT文）
  △更新する（INSERT,UPDATE,DELETE文)
    →参照元のテーブルにも影響が及ぶため、取り扱いには要注意！
      複数のテーブルにまたがる更新作業はできない！

【確認】
 [リスト10-17]ビュー→参照元テーブル
【確認】SELECT * FROM uriage WHERE idur=2017090002; →charge=194400
        UPDATE uriagedenwa SET charge=200000 WHERE idur=2017090002;
【確認】SELECT * FROM uriage WHERE idur=2017090002; →charge=200000

 [追加作業]   参照元テーブル→ビュー
        UPDATE uriage SET charge=194400 WHERE idur=2017090002;
        SELECT * FROM uriagedenwa WHERE idur=2017090002;

 [リスト10-18]
        UPDATE uriagedenwa SET charge=200000,tel='03-2222-9999'
        WHERE idur=2017090002;
        ※複数のテーブルに変更を与えることはできない！エラーになる。
          ビューには存在するが、変更後の影響を与えるテーブルが
          複数になってしまう為、この更新はできない。

【ビューの削除】
  ※削除対象はビューのみであり、参照元のテーブルには影響しない！
 [基本構文] DROP VIEW ビュー名;←DELETE文ではない！

【確認】
 [リスト10-20] DROP VIEW uriagedenwa;